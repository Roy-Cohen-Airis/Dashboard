import dash
import pandas as pd
from dash import dcc, html, dash_table, Input, Output, State
import dash_bootstrap_components as dbc
import dash_leaflet as dl
import dash.exceptions
import numpy as np
import calendar
import plotly.express as px
import plotly.graph_objects as go
from googleapiclient.discovery import build
from google.oauth2.service_account import Credentials
import ast
import json
import re
import os
from shapely.geometry import Point, Polygon
import random  # For selecting a random marker

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from oauth2client.client import GoogleCredentials
from google.oauth2 import service_account

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])
app.title = "Geo-Location Hub"

# Path to your service account key file
SERVICE_ACCOUNT_FILE = r"C:\Users\roy\OneDrive\Desktop\ASR JSONS\Geo_Anlysis_Data\arabic-transcription-435113-c8120df00a35.json"

# Authenticate and connect to the Sheets API
creds = Credentials.from_service_account_file(
    SERVICE_ACCOUNT_FILE, scopes=["https://www.googleapis.com/auth/spreadsheets.readonly"]
)
service = build('sheets', 'v4', credentials=creds)
sheet = service.spreadsheets()


SERVICE_ACCOUNT_FILE = r"C:\Users\roy\OneDrive\Desktop\ASR JSONS\Geo_Analysis\arabic-transcription-435113-c5acf93c0185.json"

# Define the required scopes
SCOPES = ['https://www.googleapis.com/auth/drive']

# Authenticate using Service Account
creds = service_account.Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)

# Build the Drive API service
drive_service = build('drive', 'v3', credentials=creds)

# Define color maps
color_map_city = {
    'Youtube': 'rgb(255,0,0)',
    'TikTok': 'rgb(255,182,193)',
    'Tik Tok': 'rgb(255,182,193)',
    'facebook': 'rgb(30,144,255)',
    'Facebook': 'rgb(30,144,255)',
    'other': 'rgb(112,128,144)',
    'Instegram': 'rgb(112,128,144)',
    'Instagram': 'green',
    
}
color_map2_city = {
    'Night Time': 'rgb(1, 1, 1)',      # Black
    'Day Time': 'rgb(236, 255, 0)'
}
color_map3_city = {
    'Clear': 'rgb(135,206,235)',
    'Snow': 'rgb(255,250,250)',
    'Rain': 'rgb(123,104,238)',
    'Fog or Smoke': 'rgb(128,128,128)'
}

color_map4_city = {
    'Prominent' : 'rgb(236, 255, 0)',
    'None': 'rgb(255,250,250)',
    'slight': 'rgb(135,206,235)'
}


# Define background style
background_style_city = {
    "background-size": "cover",
    "background-position": "center",
    "height": "350vh",
    "padding": "10px",
    "background-color": 'black',
}
# Common styles
container_style = {
    "background-color": "black",
    "border-radius": "50px",
    "padding": "15px",
    "box-shadow": "0px 8px 20px rgba(0, 0, 0, 0.3)",
    "width": "150%",
    "max-width": "1800px",
    "margin": "0 auto",
}
background_style = {
    "background-size": "cover",
    "background-color": 'black',
    "background-position": "center",
    "height": "200vh",
    "padding": "10px",
}

button_style_city = {
    "width": "50%",
    "height": "60px",
    "margin": "30px",
    "background-color": 'yellow',
    "border": "2px solid white",
    "display": "block",
    "font-weight": "bold",
    "color": "black",
    "borderRadius": "50px",
}

button_dropouts = {
    "width": "30%",
    "height": "60px",
    "margin": "-50px 0px 0px 1100px",
    "background-color": 'black',
    "border": "2px solid white",
    "display": "block",
    "font-weight": "bold",
    "color": "white",
    "borderRadius": "50px",    
}

button_style15 = {
    "width": "120%",
    "height": "60px",
    "margin": "20px",
    "background-color": 'white',
    "border": "2px solid white",
    "display": "block",
    "font-weight": "bold",
    "color": "rgb(255,51,153)",
    "borderRadius": "50px",   
}
button_polygon = {
    "width": "15%",
    "height": "60px",
    "margin": "-50px 0px 0px 850px",
    "background-color": 'blue',
    "border": "2px solid white",
    "display": "block",
    "font-weight": "bold",
    "color": "white",     
    "borderRadius": "50px",  
}
font_style = {
    "color": "white",
    "size": "25px",
    'font-weight': 'bold'
}
tab_style = {
    'background-color': 'black',
    'color': 'rgb(255,51,153)',
    'font-size': '24px',
}
selected_tab_style = {
    'background-color': 'gray',
    'color': 'rgb(255,51,153)',
    'font-size': '24px',
    'padding': '10px',
    'font-weight': 'bold'
}
# Function to load a city's data from Google Sheets
def load_city(sheet_id, sheet_range):
    result = sheet.values().get(spreadsheetId=sheet_id, range=sheet_range).execute()
    values = result.get('values', [])
    if values:
        headers = values[0]
        data = values[1:]
        df_city = pd.DataFrame(data, columns=headers)
    else:
        df_city = pd.DataFrame()
    return df_city

def convert_to_minutes(duration):
    try:
        parts = list(map(int, duration.split(':')))
        if len(parts) == 2:  # mm:ss format
            minutes, seconds = parts
            total_seconds = minutes * 60 + seconds
        elif len(parts) == 3:  # h:mm:ss format
            hours, minutes, seconds = parts
            total_seconds = hours * 3600 + minutes * 60 + seconds
        else:
            return None  # Invalid format
        return total_seconds  # Convert total seconds to minutes
    except (ValueError, AttributeError):
        return None  # Handle invalid inputs

def calculate_duration(row):
    try:
        def parse_time(time_str):
            # Check if the time includes hours
            time_parts = list(map(int, time_str.split(':')))
            if len(time_parts) == 3:  # h:mm:ss
                h, m, s = time_parts
            elif len(time_parts) == 2:  # mm:ss
                h, m, s = 0, time_parts[0], time_parts[1]
            else:
                raise ValueError("Invalid time format")
            return h * 3600 + m * 60 + s
        
        # Parse Start Time
        start_seconds = parse_time(row['Start Time'])
        # Parse Finish Time
        finish_seconds = parse_time(row['Finish Time'])
        # Calculate Duration
        return finish_seconds - start_seconds
    except Exception as e:
        print(f"Error parsing row: {e}")
        return None


def apply_all_filters2(
    df,
    duration_range,
    selected_terrain,
    selected_occluded,
    selected_VQ,
    selected_tilt,
    selected_distance,
    bar_weather_clickData,
    pie_clickData,
    pie_2_clickData,
    bar_2_clickData,
    polygon_active
):
    # Ensure the Duration column exists
    if 'Duration' not in df.columns and 'Finish Time' in df.columns and 'Start Time' in df.columns:
        df['Duration'] = df['Finish Time'].apply(convert_to_minutes) - df['Start Time'].apply(convert_to_minutes)
    
    # Apply the range filter on Duration
    if duration_range:
        df = df[(df['Duration'] >= duration_range[0]) & (df['Duration'] <= duration_range[1])]
    
    # Then apply each dropdown filter (skip if value is 'All')
    if selected_terrain != 'All':
        df = df[df['Terrain'].notna() & (df['Terrain'] == selected_terrain)]
    if selected_occluded != 'All':
        df = df[df['Occluded'].notna() & (df['Occluded'] == selected_occluded)]
    if selected_VQ != 'All':
        df = df[df['Video quality'].notna() & (df['Video quality'] == selected_VQ)]
    if selected_tilt != 'All':
        df = df[df['Camera tilt'].notna() & (df['Camera tilt'] == selected_tilt)]
    if selected_distance != 'All':
        df = df[df['Distance from building'].notna() & (df['Distance from building'] == selected_distance)]

    # Now apply bar_clickData / pie_clickData filters
    if bar_weather_clickData:
        clicked_weather = bar_weather_clickData['points'][0]['y']
        df = df[df['Weather'] == clicked_weather]
    if pie_clickData:
        clicked_time_of_day = pie_clickData['points'][0]['label']
        df = df[df['Time of the day'] == clicked_time_of_day]
    if pie_2_clickData:
        clicked_source = pie_2_clickData['points'][0]['label']
        df = df[df['Source'] == clicked_source]
    if bar_2_clickData:
        clicked_logos = bar_2_clickData['points'][0]['x']
        df = df[df['Logos and text'] == clicked_logos]
    return df


def create_map_markers(df):
    """Generate a list of Dash Leaflet Markers from the DataFrame's lat/lon."""
    markers = []
    for i, row in df.iterrows():
        coord = row['Coordinates']
        if isinstance(coord, str) and ',' in coord.lower() and 'not found' not in coord.lower():
            try:
                lat, lon = coord.split(',')
                lat, lon = float(lat), float(lon)
                markers.append(
                    dl.Marker(
                        position=(lat, lon),
                        children=[dl.Popup(coord)],
                        id=f"city-mark-{i}"
                    )
                )
            except ValueError:
                pass  # skip invalid coords
    return markers

def generate_interactive_bar_plot_2_city(df):
    source_counts = df['Logos and text'].value_counts().reset_index()
    source_counts.columns = ['Logos and text', 'Count']
    source_counts['Percentage'] = (source_counts['Count'] / source_counts['Count'].sum()) * 100
    
    fig = px.bar(
        source_counts, 
        x='Logos and text', 
        y='Count', 
        color='Logos and text', 
        color_discrete_map=color_map4_city,
        title='Logos and text Distribution',
        text=source_counts['Percentage'].apply(lambda x: f'{x:.2f}%')  # Adding percentage labels
    )
    
    fig.update_traces(
        marker_line_width=1.5, 
        hovertemplate="Count: %{y}<br>Percentage: %{text}", 
        textposition='outside',
        textfont=dict(size=22)
    )
    
    fig.update_layout(
        xaxis_title="Logos and text", 
        yaxis_title="Count", 
        showlegend=False,
        hovermode="x unified",
        font=dict(size=16, color='white'),
        plot_bgcolor='black',
        paper_bgcolor='black',
        title_font=dict(color='white'),
        xaxis=dict(
            color='white',
            gridcolor='gray',
            zerolinecolor='gray',
            title_font=dict(color='white'),
            tickfont=dict(color='white')
        ),
        yaxis=dict(
            color='yellow',
            gridcolor='gray',
            zerolinecolor='gray',
            title_font=dict(color='white'),
            tickfont=dict(color='white'),
            range=[source_counts['Count'].min(), 1.10*(source_counts['Count'].max())]
        ),
        hoverlabel=dict(font=dict(size=24, color='white'))
    )
    
    return fig


def generate_interactive_pie_chart_city(df):
    tod_counts = df['Time of the day'].value_counts().reset_index()
    tod_counts.columns = ['Time of the day', 'Count']
    fig = px.pie(
        tod_counts,
        names='Time of the day',
        values='Count',
        color='Time of the day',
        color_discrete_map=color_map2_city,
        title='Time'
    )
    fig.update_traces(
        marker=dict(line=dict(color='white', width=2)),
        textinfo='label+percent',
        textfont=dict(color='yellow', size=22)
    )
    fig.update_layout(
        showlegend=False,
        hovermode="x unified",
        margin=dict(t=40, b=20, l=0, r=0),
        font=dict(size=16, color='white'),
        plot_bgcolor='black',
        paper_bgcolor='black',
        title_font=dict(color='white', size=24),
        hoverlabel=dict(font=dict(size=24, color='white'))
    )
    return fig

import plotly.express as px

def generate_interactive_bar_chart_weather_city(df):
    weather_counts = df['Weather'].value_counts().reset_index()
    weather_counts.columns = ['Weather', 'Count']
    weather_counts['Percentage'] = (weather_counts['Count'] / weather_counts['Count'].sum()) * 100
    
    fig = px.bar(
        weather_counts,
        y='Weather',
        x='Count',
        orientation='h',
        color='Weather',
        color_discrete_map=color_map3_city,
        title='Weather',
        text=weather_counts['Percentage'].apply(lambda x: f'{x:.2f}%')  # Adding percentage labels
    )
    
    fig.update_traces(
        marker_line_width=1.5,
        hovertemplate="Count: %{x}<br>Percentage: %{text}",
        textposition='outside',
        textfont=dict(size=22)
    )
    
    fig.update_layout(
        xaxis_title="Count",
        yaxis_title="Weather",
        showlegend=False,
        hovermode="y unified",
        font=dict(size=16, color='white'),
        plot_bgcolor='black',
        paper_bgcolor='black',
        title_font=dict(color='white', size=24),
        xaxis=dict(
            color='yellow',
            gridcolor='gray',
            zerolinecolor='gray',
            title_font=dict(color='white'),
            tickfont=dict(color='white'),
            range=[0, 1.25*(weather_counts['Count'].max())]  # Adjusted range calculation
        ),
        yaxis=dict(
            color='white',
            gridcolor='gray',
            zerolinecolor='gray',
            title_font=dict(color='white'),
            tickfont=dict(color='white')
        ),
        margin=dict(t=40, b=20, l=0, r=0),
        hoverlabel=dict(font=dict(size=24, color='white'))
    )
    
    return fig


import plotly.express as px

def generate_interactive_pie_chart_source(df):
    color_map = {
        'done': '#006400',
        'not started': '#FF0000',
        'not found': '#DC143C',
        'irrelevant': '#00FFFF'
    }
    
    source_counts = df['Source'].value_counts().reset_index()
    source_counts.columns = ['Source', 'Count']
    
    fig = px.pie(
        source_counts,
        names='Source',
        values='Count',
        color='Source',
        color_discrete_map=color_map,
        title='Source Distribution'
    )
    
    fig.update_traces(
        marker=dict(line=dict(color='white', width=2)),
        textinfo='label+percent',  # Added percent here
        textfont=dict(color='yellow', size=22)
    )
    
    fig.update_layout(
        showlegend=False,
        hovermode="x unified",
        margin=dict(t=40, b=20, l=0, r=0),
        font=dict(size=16, color='white'),
        plot_bgcolor='black',
        paper_bgcolor='black',
        title_font=dict(color='white', size=24),
        hoverlabel=dict(font=dict(size=24, color='white'))
    )
    
    return fig


def city_load_data():
    SHEET_ID = '1Svc-2iK5wvHFicmBZHoOxqf5iajdg57ntilgR_cM3ZE'
    RANGE = 'Cities!A1:E300'
    result = sheet.values().get(spreadsheetId=SHEET_ID, range=RANGE).execute()
    values = result.get('values', [])
    if values:
        headers_n = values[0]
        data_n = values[1:]
        df_Cities = pd.DataFrame(data_n, columns=headers_n)
    else:
        print("No data found for Naples.")
        df_Cities = pd.DataFrame()
    return df_Cities

global cities
cities = city_load_data()
states = cities['Country'].unique()

@app.callback([
    Output('city_filter', 'options'),
    Output('city_filter', 'value'),],
[
    Input('state_filter', 'value'),
]
)
def update_city_data(selected_country):
    city_options = cities[cities['Country'] == selected_country]['City Name'].unique()
    city_value=city_options[0]
    return(
         [{'label': city, 'value': city} for city in city_options],
         city_value
    )

def tab_layout():
    return html.Div(
        style=background_style,
        children=[  
            html.Img(
                src="/assets/airis.png", 
                alt="Airis Logo", 
                style={
                    "width": "200px", 
                    "position": "absolute",  
                    "top": "80px",          
                    "left": "10px",         
                    "zIndex": "1000"        
                }
            ), 
            dcc.Store(id='data', data=None),
            dcc.Store(id='current-city-data', data=None),
            dcc.Store('polygon_drop_active', data=False),
            dcc.Store(id='polygon-coords-store', data=None),
            dcc.Store(id='reset_button_clicked', data=False),

            dbc.Container(
                style=container_style,
                children=[
                    html.H1(
                        children=f"Airis-Labs: Geo-Location Analysis",
                        className='mb-4',
                        style={'textAlign': 'center', 'color': 'rgb(255,51,153)'},
                        id='city_name'
                    ),
                    dbc.Row([
                        dbc.Col([
                            dl.Map(
                                id='map',
                                children=[
                                    dl.TileLayer(),
                                    dl.LayerGroup(id="map-layer", children=[]),
                                    dl.LayerGroup(id="polygon-layer", children=[]),
                                ],
                                center=(41.9028, 12.4964),  
                                zoom=10,
                                style={"width": "100%", "height": "500px", "margin": "6px"}
                            ),
                            dbc.Row([
                                dbc.Col(
                                    html.Div([
                                        dbc.Label("Select A Country:", style=font_style),
                                        dcc.Dropdown(
                                            id='state_filter',
                                            options=[{'label': r, 'value': r} for r in states],
                                            value='Italy',
                                            className="form-control mb-2"
                                        )
                                    ]), width=4
                                ),
                                dbc.Col(
                                    html.Div([
                                        dbc.Label("Select A City:", style=font_style),
                                        dcc.Dropdown(
                                            id='city_filter',
                                            options=[],
                                            value=[], 
                                            multi=True,
                                            className="form-control mb-2"
                                        )
                                    ]), width=4
                                ),
                                dbc.Col(
                                    dbc.Button(
                                        "Load",
                                        id='city-filter-btn',
                                        color='primary',
                                        n_clicks=0,
                                        style=button_style_city
                                    ),
                                    width=4
                                )  
                            ])
                        ], width=7),                 
                        
                        dbc.Col([
                            dbc.Row([
                                dbc.Col([
                                    html.Div([
                                        html.H4("Filters", className='mb-3', style={'textAlign': 'left', 'color': 'rgb(255,51,153)'}),
                                        dbc.Label("Terrain Filtering:", style=font_style),
                                        dcc.Dropdown(id='Terrain', options=[], value=None, className="form-control mb-2"),
                                        dbc.Label("Camera Tilt Filtering:", style=font_style),
                                        dcc.Dropdown(id='Camera_Tilt', options=[], value=None, className="form-control mb-2"),
                                        dbc.Label("Occlusion Filtering:", style=font_style),
                                        dcc.Dropdown(id='Occlusion', options=[], value=None, className="form-control mb-2"),
                                        dbc.Label("Video Quality Filtering:", style=font_style),
                                        dcc.Dropdown(id='VQ', options=[], value=None, className="form-control mb-2"),
                                        dbc.Label("Distance Filtering:", style=font_style),
                                        dcc.Dropdown(id='Distance_Building', options=[], value=None, className="form-control mb-2"),
                                        dbc.Row([
                                            dbc.Col(dbc.Button("Update DB & Reset Filters", id='update', color='primary', n_clicks=0, style=button_style15), width="auto"),
                                        ]),
                                    ], style={"marginBottom": "30px"}),
                                ], width=6),

                                dbc.Col([
                                    html.Div([
                                        html.H4("Filter/City Comparison:", className='mb-4', style={'textAlign': 'center', 'color': 'rgb(255,51,153)'}),
                                        html.Br(),
                                        dash_table.DataTable(
                                            id='filter_comp',
                                            columns=[
                                                {"name": "Filter", "id": "Filter"},
                                                {"name": "City", "id": "City"},
                                                {"name": "Percentage", "id": "Percentage"},
                                            ],
                                            data=[],
                                            sort_action="native",
                                            filter_action="native",
                                            fixed_rows={'headers': True},
                                            style_table={'maxHeight': '500px', 'overflowX': 'auto', 'overflowY': 'auto'},
                                            style_cell={
                                                'textAlign': 'center',
                                                'width': '30px',
                                                'maxWidth': '30px',
                                                'whiteSpace': 'nowrap',
                                                'overflow': 'hidden',
                                                'textOverflow': 'ellipsis',
                                            },
                                            style_header={
                                                'backgroundColor': 'rgb(30, 30, 30)',
                                                'color': 'white',
                                                'fontWeight': 'bold',
                                            },
                                            style_data_conditional=[]
                                        ),
                                    ]),  
                                ], width=6),
                            ])
                        ], width=5),
                    ]),
                    
                    html.H1(
                        id='record-count',
                        children="Total Records: 0",
                        style={'textAlign': 'center', 'fontWeight': 'bold', 'marginTop': '0', 'color': 'rgb(255,51,153)'}
                    ),
                    html.Br(),
                    html.H2(
                        id='drop-pre',
                        children=f"0% out of Poylgon",
                        style={'textAlign': 'center', 'fontWeight': 'bold', 'marginTop': '0', 'color': 'rgb(255,51,153)'}
                    ),
                    dbc.Col(
                        dbc.Button(
                            "Show Dropouts",
                            id='dropouts',
                            color='primary',
                            n_clicks=0,
                            style=button_dropouts
                        ),
                        width=4
                    ),                      
                    html.Br(),
                    html.H4("Filter by Video Duration (seconds):", className='mb-1', style={'textAlign': 'left', 'color': 'rgb(255,51,153)'}),
                    dbc.Row([
                        dbc.Col(
                            dcc.RangeSlider(
                                id='duration-slider',
                                min=0,
                                max=100,
                                step=0.1,
                                value=[0, 100],
                                updatemode='mouseup',
                                marks={},
                                tooltip={"always_visible": True, "placement": "bottom"}
                            ), width=8
                        )
                    ], justify="left"),
                    
                    html.Div([
                        html.H4("Graphical Analysis", className='mb-3', style={'textAlign': 'left', 'color': 'rgb(255,51,153)'}),      
                        html.Div(
                            id="graphs-container",
                            style={"display": "none"},  
                            children=[
                                dbc.Row([
                                    dbc.Col(dcc.Graph(id='pie-chart', figure={}), width=6),
                                    dbc.Col(dcc.Graph(id='bar-chart-weather', figure={}), width=6),
                                    dbc.Col(dcc.Graph(id='bar-plot-logos', figure={}), width=6),
                                    dbc.Col(dcc.Graph(id='source-pie', figure={}), width=6),
                                ]),
                            ],
                        ),
                    ], style={'marginTop': '20px'}),
                    
                    html.Div([
                        html.H1("Full Details:", className='mb-4', style={'textAlign': 'center', 'color': 'rgb(255,51,153)'}),
                        html.Hr(),
                        dash_table.DataTable(
                            id='table',
                            columns=[],
                            data=[],
                            sort_action="native",
                            filter_action="native",
                            fixed_rows={'headers': True},
                            style_table={'maxHeight': '500px', 'overflowX': 'auto', 'overflowY': 'auto'},
                            style_cell={
                                'textAlign': 'center',
                                'width': '100px',
                                'maxWidth': '100px',
                                'whiteSpace': 'nowrap',
                                'overflow': 'hidden',
                                'textOverflow': 'ellipsis',
                            },
                            style_header={
                                'backgroundColor': 'rgb(30, 30, 30)',
                                'color': 'white',
                                'fontWeight': 'bold',
                            },
                            style_data_conditional=[]
                        ),
                    ]),
                ]
            )
        ]
    )




    
@app.callback(
    [Output('map', 'center'),
     Output('map-layer', 'children'),
     Output('polygon-layer', 'children'),
     Output('Terrain', 'options'),
     Output('Terrain', 'value'),
     Output('Occlusion', 'options'),
     Output('Occlusion', 'value'),
     Output('VQ', 'options'),
     Output('VQ', 'value'),
     Output('Camera_Tilt', 'options'),
     Output('Camera_Tilt', 'value'),
     Output('Distance_Building', 'options'),
     Output('Distance_Building', 'value'),
     Output('record-count', 'children'),
     Output('drop-pre', 'children'),
     Output('duration-slider', 'min'),
     Output('duration-slider', 'max'),
     Output('duration-slider', 'value'),
     Output('pie-chart', 'figure'),
     Output('bar-chart-weather', 'figure'),
     Output('bar-plot-logos', 'figure'),
     Output('source-pie', 'figure'),
     Output('pie-chart', 'clickData'),
     Output('bar-chart-weather', 'clickData'),
     Output('bar-plot-logos', 'clickData'),
     Output('source-pie', 'clickData'),
     Output('city_name','children'),
     Output('table', 'data'),
     Output('table', 'columns'),
     Output('current-city-data','data'),
     Output('reset_button_clicked','data'),
     Output('graphs-container', 'style'),
     Output('polygon_drop_active','data'),
     Output('polygon-coords-store', 'data')
    ],
    [Input('city-filter-btn', 'n_clicks'),
     Input('city_filter', "value"),
     Input('update','n_clicks'),
     Input('pie-chart', 'clickData'),
     Input('bar-chart-weather', 'clickData'),
     Input('bar-plot-logos', 'clickData'),
     Input('source-pie','clickData'),
     Input('duration-slider', 'value'),
     Input('Terrain', 'value'),
     Input('Occlusion', 'value'),
     Input('VQ', 'value'),
     Input('Camera_Tilt', 'value'),
     Input('Distance_Building', 'value'),
     Input('dropouts','n_clicks')],
    [State('current-city-data','data'),
     State('reset_button_clicked','data'),
     State('polygon_drop_active','data'),
     State('polygon-coords-store', 'data')]
)
def load_dashboards(load_btn, selected_city, update, pie_clickData, 
                    bar_weather_clickData, bar_clickData, pie2_clickData, duration_range,
                    selected_terrain, selected_occluded, selected_VQ, selected_tilt, selected_distance,
                    dropouts_n_clicks,
                    current_data, reset_clicked, polygon_active, polygon_coords_store):
    ctx = dash.callback_context
    triggered_id = ctx.triggered[0]['prop_id'] if ctx.triggered else None

    # If the city dropdown changes without a button click, do nothing.
    if triggered_id and triggered_id.startswith('city_filter'):
        return (dash.no_update,) * 34

    # Reset chart clickData if they weren’t the trigger.
    if triggered_id != 'pie-chart.clickData':
        pie_clickData = None
    if triggered_id != 'bar-chart-weather.clickData':
        bar_weather_clickData = None    
    if triggered_id != 'bar-plot-logos.clickData':
        bar_clickData = None
    if triggered_id != 'source-pie.clickData':
        pie2_clickData = None

    # Helper: Build dropdown options for a given column.
    def build_options(df, col_name):
        if col_name in df.columns:
            unique_vals = sorted([v for v in df[col_name].unique() if pd.notnull(v)])
            return [{'label': 'All', 'value': 'All'}] + [{'label': str(val), 'value': str(val)} for val in unique_vals]
        return []

    # Helper: Load selected cities’ sheet IDs, ranges, and polygon IDs.
    def load_selected_cities(selected_cities):
        if not selected_cities:
            return [], [], []
        # If only one city is selected, wrap it in a list.
        if isinstance(selected_cities, str):
            selected_cities = [selected_cities]
        filtered_cities = cities[cities['City Name'].isin(selected_cities)]
        sheet_ids = filtered_cities['Sheet ID'].tolist()
        sheet_ranges = filtered_cities['Sheet Range'].tolist()
        polygon_ids = filtered_cities['PolygonID'].tolist()
        return sheet_ids, sheet_ranges, polygon_ids


    # --- Branch 1: Load Button (city-filter-btn) ---
    if triggered_id == 'city-filter-btn.n_clicks':
        reset_clicked = False
        sheet_ids, sheet_ranges, polygon_ids = load_selected_cities(selected_city)
        combined_dfs = []
        polygons_list = []  # Will store each city’s polygon coordinates list.
        for sid, srange, pid in zip(sheet_ids, sheet_ranges, polygon_ids):
            # Load polygon data from Drive.
            request = drive_service.files().get_media(fileId=pid)
            polygon_bytes = request.execute()
            try:
                if isinstance(polygon_bytes, bytes):
                    polygon_data = json.loads(polygon_bytes.decode('utf-8'))
                else:
                    polygon_data = json.loads(polygon_bytes)
            except Exception:
                polygon_data = []
            poly_coords = [tuple(coord) for coord in polygon_data]
            polygons_list.append(poly_coords)
            # Load the city data from Sheets.
            df_city = load_city(sid, srange)
            combined_dfs.append(df_city)
        if combined_dfs:
            df_combined = pd.concat(combined_dfs, ignore_index=True)
        else:
            df_combined = pd.DataFrame()

        # Build a polygon layer with one polygon per city.
        polygon_layers = []
        for poly_coords in polygons_list:
            if poly_coords:
                city_poly = Polygon(poly_coords)
                polygon_layers.append(
                    dl.Polygon(
                        positions=list(city_poly.exterior.coords),
                        color="blue",
                        fillColor="cyan",
                        fillOpacity=0.6,
                    )
                )
        polygon_layer = dl.LayerGroup(children=polygon_layers)

        # Process the combined DataFrame (ensure valid Coordinates, extract lat/lon).
        if 'Coordinates' in df_combined.columns:
            df_combined = df_combined[df_combined['Coordinates'].str.contains(',', na=False)]
            df_combined[['Latitude', 'Longitude']] = df_combined['Coordinates'].str.split(',', expand=True)
            df_combined['Latitude'] = pd.to_numeric(df_combined['Latitude'], errors='coerce')
            df_combined['Longitude'] = pd.to_numeric(df_combined['Longitude'], errors='coerce')
            city_markers = create_map_markers(df_combined)
        else:
            city_markers = []

        # Helper: Check if a point is inside any of the loaded polygons.
        def is_inside_any(lat, lon, polygons):
            pt = Point(lat, lon)
            for poly in polygons:
                if poly and Polygon(poly).contains(pt):
                    return True
            return False

        count_within = sum(
            is_inside_any(row['Latitude'], row['Longitude'], polygons_list)
            for _, row in df_combined.iterrows()
            if pd.notnull(row['Latitude']) and pd.notnull(row['Longitude'])
        )
        pre_out_city = round(((len(df_combined) - count_within) / len(df_combined) * 100), 2) if len(df_combined) > 0 else 0

        if 'Duration' not in df_combined.columns:
            df_combined['Duration'] = df_combined['Finish Time'].apply(convert_to_minutes) - df_combined['Start Time'].apply(convert_to_minutes)
        df_combined.dropna(subset=['Latitude', 'Longitude'], inplace=True)
        min_dur = df_combined['Duration'].min() if not df_combined['Duration'].empty else 0
        max_dur = df_combined['Duration'].max() if not df_combined['Duration'].empty else 100
        record_count = f"Total Records: {len(df_combined)}"
        drop_count = f"{pre_out_city} % out of Polygon"
        if city_markers:
            random_marker = random.choice(city_markers)
            map_center = random_marker.position
        else:
            map_center = (41.9028, 12.4964)

        # Generate charts based on the combined DataFrame.
        city_logos_bar = generate_interactive_bar_plot_2_city(df_combined)
        city_time_of_day_pie = generate_interactive_pie_chart_city(df_combined)
        city_weather_bar = generate_interactive_bar_chart_weather_city(df_combined)
        city_source_pie = generate_interactive_pie_chart_source(df_combined)

        title = f"Airis-Labs: Geo-Location Analysis - {', '.join(selected_city) if isinstance(selected_city, list) else selected_city}"
        return (
            map_center,                                # map center
            city_markers,                              # map-layer children
            polygon_layer,                             # polygon-layer children
            build_options(df_combined, 'Terrain'),     # Terrain dropdown options
            'All',                                     # Terrain value
            build_options(df_combined, 'Occluded'),      # Occlusion dropdown options
            'All',                                     # Occlusion value
            build_options(df_combined, 'Video quality'), # VQ dropdown options
            'All',                                     # VQ value
            build_options(df_combined, 'Camera tilt'),   # Camera_Tilt dropdown options
            'All',                                     # Camera_Tilt value
            build_options(df_combined, 'Distance from building'),  # Distance_Building options
            'All',                                     # Distance_Building value
            record_count,                              # record-count text
            drop_count,                                # drop-pre text
            min_dur,                                   # duration-slider min
            max_dur,                                   # duration-slider max
            [min_dur, max_dur],                        # duration-slider current value
            city_time_of_day_pie,                      # pie-chart figure
            city_weather_bar,                          # bar-chart-weather figure
            city_logos_bar,                            # bar-plot-logos figure
            city_source_pie,                           # source-pie figure
            dash.no_update,                           # pie-chart clickData (reset)
            dash.no_update,                           # bar-chart-weather clickData (reset)
            dash.no_update,                           # bar-plot-logos clickData (reset)
            dash.no_update,                           # source-pie clickData (reset)
            title,                                     # city_name text
            df_combined.to_dict('records'),            # table data
            [{'name': col, 'id': col} for col in df_combined.columns],  # table columns
            df_combined.to_dict('records'),            # current-city-data store
            reset_clicked,                             # reset_button_clicked store
            {"display": "block"},                      # graphs-container style
            polygons_list,                             # polygon_drop_active data (list of polygons)
            polygons_list                              # polygon-coords-store data (list of polygons)
        )
    
    # --- Branch 2: Update & Reset Button (update.n_clicks) ---
    elif triggered_id == 'update.n_clicks':
        reset_clicked = True
        sheet_ids, sheet_ranges, polygon_ids = load_selected_cities(selected_city)
        combined_dfs = []
        polygons_list = []
        for sid, srange, pid in zip(sheet_ids, sheet_ranges, polygon_ids):
            request = drive_service.files().get_media(fileId=pid)
            polygon_bytes = request.execute()
            try:
                if isinstance(polygon_bytes, bytes):
                    polygon_data = json.loads(polygon_bytes.decode('utf-8'))
                else:
                    polygon_data = json.loads(polygon_bytes)
            except Exception:
                polygon_data = []
            poly_coords = [tuple(coord) for coord in polygon_data]
            polygons_list.append(poly_coords)
            df_city = load_city(sid, srange)
            combined_dfs.append(df_city)
        if combined_dfs:
            df_updated = pd.concat(combined_dfs, ignore_index=True)
        else:
            df_updated = pd.DataFrame()

        if 'Coordinates' in df_updated.columns:
            df_updated = df_updated[df_updated['Coordinates'].str.contains(',', na=False)]
            df_updated[['Latitude', 'Longitude']] = df_updated['Coordinates'].str.split(',', expand=True)
            df_updated['Latitude'] = pd.to_numeric(df_updated['Latitude'], errors='coerce')
            df_updated['Longitude'] = pd.to_numeric(df_updated['Longitude'], errors='coerce')
            city_markers = create_map_markers(df_updated)
        else:
            city_markers = []

        def is_inside_any(lat, lon, polygons):
            pt = Point(lat, lon)
            for poly in polygons:
                if poly and Polygon(poly).contains(pt):
                    return True
            return False

        count_within = sum(
            is_inside_any(row['Latitude'], row['Longitude'], polygons_list)
            for _, row in df_updated.iterrows()
            if pd.notnull(row['Latitude']) and pd.notnull(row['Longitude'])
        )
        pre_out_city = round(((len(df_updated) - count_within) / len(df_updated) * 100), 2) if len(df_updated)>0 else 0

        if 'Duration' not in df_updated.columns:
            df_updated['Duration'] = df_updated['Finish Time'].apply(convert_to_minutes) - df_updated['Start Time'].apply(convert_to_minutes)
        df_updated.dropna(subset=['Latitude', 'Longitude'], inplace=True)
        min_dur = df_updated['Duration'].min() if not df_updated['Duration'].empty else 0
        max_dur = df_updated['Duration'].max() if not df_updated['Duration'].empty else 100
        record_count = f"Total Records: {len(df_updated)}"
        drop_count = f"{pre_out_city} % out of Polygon"
        if city_markers:
            random_marker = random.choice(city_markers)
            map_center = random_marker.position
        else:
            map_center = (41.9028, 12.4964)
        city_logos_bar = generate_interactive_bar_plot_2_city(df_updated)
        city_time_of_day_pie = generate_interactive_pie_chart_city(df_updated)
        city_weather_bar = generate_interactive_bar_chart_weather_city(df_updated)
        city_source_pie = generate_interactive_pie_chart_source(df_updated)
        title = f"Airis-Labs: Geo-Location Analysis - {', '.join(selected_city) if isinstance(selected_city, list) else selected_city}"
        return (
            map_center,
            city_markers,
            dash.no_update,  # Keeping existing polygon layer
            build_options(df_updated, 'Terrain'),
            'All',
            build_options(df_updated, 'Occluded'),
            'All',
            build_options(df_updated, 'Video quality'),
            'All',
            build_options(df_updated, 'Camera tilt'),
            'All',
            build_options(df_updated, 'Distance from building'),
            'All',
            record_count,
            drop_count,
            min_dur,
            max_dur,
            [min_dur, max_dur],
            city_time_of_day_pie,
            city_weather_bar,
            city_logos_bar,
            city_source_pie,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            dash.no_update,
            title,
            df_updated.to_dict('records'),
            [{'name': col, 'id': col} for col in df_updated.columns],
            df_updated.to_dict('records'),
            reset_clicked,
            {"display": "block"},
            polygons_list,
            polygons_list
        )
    
    # --- Branch 3: Dropouts Filtering (dropouts.n_clicks) ---
    elif triggered_id == 'dropouts.n_clicks' and dropouts_n_clicks > 0:
        df_filtered = pd.DataFrame(current_data)
        polygon_active = True
        filtered_df = apply_all_filters2(
            df=df_filtered,
            duration_range=duration_range,
            selected_terrain=selected_terrain,
            selected_occluded=selected_occluded,
            selected_VQ=selected_VQ,
            selected_tilt=selected_tilt,
            selected_distance=selected_distance,
            bar_weather_clickData=bar_weather_clickData,
            pie_clickData=pie_clickData,
            pie_2_clickData=pie2_clickData,
            bar_2_clickData=bar_clickData,
            polygon_active=polygon_active
        )
        if 'Coordinates' in filtered_df.columns:
            filtered_df = filtered_df[filtered_df['Coordinates'].str.contains(',', na=False)]
            temp = filtered_df['Coordinates'].str.split(',', n=1, expand=True)
            filtered_df['Latitude'] = pd.to_numeric(temp[0], errors='coerce')
            filtered_df['Longitude'] = pd.to_numeric(temp[1], errors='coerce')
            
        else:
            city_markers = []

        # Initialize polygons_list from state (list of polygons for each city)
        polygons_list = polygon_coords_store if polygon_coords_store is not None else []

        # Helper: Check if a point is inside any of the loaded polygons.
        def is_inside_any_poly(row):
            pt = Point(row['Latitude'], row['Longitude'])
            return any(Polygon(poly).contains(pt) for poly in polygons_list if poly)

        # Calculate total number of records and how many are inside any polygon.
        total_count = len(filtered_df)
        count_inside = filtered_df.apply(is_inside_any_poly, axis=1).sum()
        dropout_percentage = round(((total_count - count_inside) / total_count * 100), 2) if total_count > 0 else 0

        # Filter the dataframe to only include dropouts (points that are NOT inside any polygon)
        filtered_df = filtered_df[~filtered_df.apply(is_inside_any_poly, axis=1)]
        city_markers = create_map_markers(filtered_df)
        if 'Duration' not in filtered_df.columns:
            filtered_df['Duration'] = filtered_df['Finish Time'].apply(convert_to_minutes) - filtered_df['Start Time'].apply(convert_to_minutes)
        filtered_df.dropna(subset=['Latitude', 'Longitude'], inplace=True)
        min_dur = filtered_df['Duration'].min() if not filtered_df['Duration'].empty else 0
        max_dur = filtered_df['Duration'].max() if not filtered_df['Duration'].empty else 100
        record_count = f"Total Records: {len(filtered_df)}"
        if city_markers:
            random_marker = random.choice(city_markers)
            map_center = random_marker.position
        else:
            map_center = (41.9028, 12.4964)
        city_logos_bar = generate_interactive_bar_plot_2_city(filtered_df)
        city_time_of_day_pie = generate_interactive_pie_chart_city(filtered_df)
        city_weather_bar = generate_interactive_bar_chart_weather_city(filtered_df)
        city_source_pie = generate_interactive_pie_chart_source(filtered_df)
        drop_count = f"{dropout_percentage} % out of Polygon" if total_count > 0 else "Nothing to show"
        return (
            map_center,
            city_markers,
            dash.no_update,
            build_options(filtered_df, 'Terrain'),
            'All',
            build_options(filtered_df, 'Occluded'),
            'All',
            build_options(filtered_df, 'Video quality'),
            'All',
            build_options(filtered_df, 'Camera tilt'),
            'All',
            build_options(filtered_df, 'Distance from building'),
            'All',
            record_count,
            drop_count,
            min_dur,
            max_dur,
            [min_dur, max_dur],
            city_time_of_day_pie,
            city_weather_bar,
            city_logos_bar,
            city_source_pie,
            pie_clickData,
            bar_clickData,
            bar_weather_clickData,
            pie2_clickData,
            dash.no_update,
            filtered_df.to_dict('records'),
            dash.no_update,
            filtered_df.to_dict('records'),
            reset_clicked,
            {"display": "block"},
            polygon_active,
            dash.no_update
        )

    
    # --- Branch 4: Default Filtering without Load/Update ---
    else:
        reset_clicked = False
        df_current = pd.DataFrame(current_data)
        if df_current.empty:
            # Reload data if necessary.
            sheet_ids, sheet_ranges, polygon_ids = load_selected_cities(selected_city)
            combined_dfs = []
            polygons_list = []
            for sid, srange, pid in zip(sheet_ids, sheet_ranges, polygon_ids):
                request = drive_service.files().get_media(fileId=pid)
                polygon_bytes = request.execute()
                try:
                    if isinstance(polygon_bytes, bytes):
                        polygon_data = json.loads(polygon_bytes.decode('utf-8'))
                    else:
                        polygon_data = json.loads(polygon_bytes)
                except Exception:
                    polygon_data = []
                poly_coords = [tuple(coord) for coord in polygon_data]
                polygons_list.append(poly_coords)
                df_city = load_city(sid, srange)
                combined_dfs.append(df_city)
            if combined_dfs:
                df_current = pd.concat(combined_dfs, ignore_index=True)
            else:
                df_current = pd.DataFrame()
            polygon_layer = dl.LayerGroup(
                children=[
                    dl.Polygon(
                        positions=list(Polygon(polygons_list[0]).exterior.coords) if polygons_list and len(polygons_list[0])>0 else [],
                        color="blue",
                        fillColor="cyan",
                        fillOpacity=0.6,
                    )
                ]
            )
            table_columns = [{'name': col, 'id': col} for col in df_current.columns]
            terrain_options = build_options(df_current, 'Terrain')
            occlusion_options = build_options(df_current, 'Occluded')
            vq_options = build_options(df_current, 'Video quality')
            camera_tilt_options = build_options(df_current, 'Camera tilt')
            distance_options = build_options(df_current, 'Distance from building')
            df_current = df_current[df_current['Coordinates'].str.contains(',', na=False)]
            temp = df_current['Coordinates'].str.split(',', n=1, expand=True)
            df_current['Latitude'] = pd.to_numeric(temp[0], errors='coerce')
            df_current['Longitude'] = pd.to_numeric(temp[1], errors='coerce')
            city_markers = create_map_markers(df_current)
            # Use the computed polygons_list here.
            # If not available, use the stored polygon_coords_store.
            if 'polygons_list' not in locals() or not polygons_list:
                polygons_list = polygon_coords_store if polygon_coords_store is not None else []
            if polygons_list and len(polygons_list) > 0:
                city_polygon = Polygon(polygons_list[0])
            else:
                city_polygon = None
            count_within = sum(
                city_polygon.contains(Point(row['Latitude'], row['Longitude']))
                for _, row in df_current.iterrows()
                if pd.notnull(row['Latitude']) and pd.notnull(row['Longitude'])
            ) if city_polygon else 0
            pre_out_city = round(((len(df_current) - count_within) / len(df_current) * 100), 2) if len(df_current)>0 else 0
            if 'Duration' not in df_current.columns:
                df_current['Duration'] = df_current['Finish Time'].apply(convert_to_minutes) - df_current['Start Time'].apply(convert_to_minutes)
            df_current.dropna(subset=['Latitude', 'Longitude'], inplace=True)
            min_dur = df_current['Duration'].min() if not df_current['Duration'].empty else 0
            max_dur = df_current['Duration'].max() if not df_current['Duration'].empty else 100
            record_count = f"Total Records: {len(df_current)}"
            drop_count = f"{pre_out_city} % out of Polygon"
            if city_markers:
                random_marker = random.choice(city_markers)
                map_center = random_marker.position
            else:
                map_center = (41.9028, 12.4964)
            title = f"Airis-Labs: Geo-Location Analysis - {', '.join(selected_city) if isinstance(selected_city, list) else selected_city}"
            city_logos_bar = generate_interactive_bar_plot_2_city(df_current)
            city_time_of_day_pie = generate_interactive_pie_chart_city(df_current)
            city_weather_bar = generate_interactive_bar_chart_weather_city(df_current)
            city_source_pie = generate_interactive_pie_chart_source(df_current)
            return (
                map_center,
                city_markers,
                polygon_layer,
                terrain_options,
                'All',
                occlusion_options,
                'All',
                vq_options,
                'All',
                camera_tilt_options,
                'All',
                distance_options,
                'All',
                record_count,
                drop_count,
                min_dur,
                max_dur,
                [min_dur, max_dur],
                city_time_of_day_pie,
                city_weather_bar,
                city_logos_bar,
                city_source_pie,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                dash.no_update,
                title,
                df_current.to_dict('records'),
                table_columns,
                df_current.to_dict('records'),
                reset_clicked,
                {"display": "block"},
                polygon_active,
                dash.no_update
            )
        else:
            reset_clicked = False
            df_filtered = pd.DataFrame(current_data)
            filtered_df = apply_all_filters2(
                df=df_filtered,
                duration_range=duration_range,
                selected_terrain=selected_terrain,
                selected_occluded=selected_occluded,
                selected_VQ=selected_VQ,
                selected_tilt=selected_tilt,
                selected_distance=selected_distance,
                bar_weather_clickData=bar_weather_clickData,
                pie_clickData=pie_clickData,
                pie_2_clickData=pie2_clickData,
                bar_2_clickData=bar_clickData,
                polygon_active=polygon_active
            )
            terrain_options = build_options(filtered_df, 'Terrain')
            occlusion_options = build_options(filtered_df, 'Occluded')
            vq_options = build_options(filtered_df, 'Video quality')
            camera_tilt_options = build_options(filtered_df, 'Camera tilt')
            distance_options = build_options(filtered_df, 'Distance from building')
            filtered_df = filtered_df[filtered_df['Coordinates'].str.contains(',', na=False)]
            temp = filtered_df['Coordinates'].str.split(',', n=1, expand=True)
            filtered_df['Latitude'] = pd.to_numeric(temp[0], errors='coerce')
            filtered_df['Longitude'] = pd.to_numeric(temp[1], errors='coerce')
            city_markers = create_map_markers(filtered_df)
            # Initialize polygons_list from state if not defined.
            polygons_list = polygon_coords_store if polygon_coords_store is not None else []
            if polygons_list and len(polygons_list) > 0:
                city_polygon = Polygon(polygons_list[0])
            else:
                city_polygon = None
            count_within = sum(
                city_polygon.contains(Point(row['Latitude'], row['Longitude']))
                for _, row in filtered_df.iterrows()
                if pd.notnull(row['Latitude']) and pd.notnull(row['Longitude'])
            ) if city_polygon else 0
            pre_out_city = round(((len(filtered_df) - count_within) / len(filtered_df) * 100), 2) if len(filtered_df)>0 else 0
            if 'Duration' not in filtered_df.columns:
                filtered_df['Duration'] = filtered_df['Finish Time'].apply(convert_to_minutes) - filtered_df['Start Time'].apply(convert_to_minutes)
            filtered_df.dropna(subset=['Latitude', 'Longitude'], inplace=True)
            min_dur = filtered_df['Duration'].min() if not filtered_df['Duration'].empty else 0
            max_dur = filtered_df['Duration'].max() if not filtered_df['Duration'].empty else 100
            record_count = f"Total Records: {len(filtered_df)}"
            drop_count = f"{pre_out_city} % out of Polygon"
            if city_markers:
                random_marker = random.choice(city_markers)
                map_center = random_marker.position
            else:
                map_center = (41.9028, 12.4964)
            title = f"Airis-Labs: Geo-Location Analysis - {', '.join(selected_city) if isinstance(selected_city, list) else selected_city}"
            return (
                map_center,
                city_markers,
                dash.no_update,
                terrain_options,
                'All',
                occlusion_options,
                'All',
                vq_options,
                'All',
                camera_tilt_options,
                'All',
                distance_options,
                'All',
                record_count,
                drop_count,
                min_dur,
                max_dur,
                [min_dur, max_dur],
                generate_interactive_pie_chart_city(filtered_df),
                generate_interactive_bar_chart_weather_city(filtered_df),
                generate_interactive_bar_plot_2_city(filtered_df),
                generate_interactive_pie_chart_source(filtered_df),
                pie_clickData,
                bar_clickData,
                bar_weather_clickData,
                pie2_clickData,
                dash.no_update,
                filtered_df.to_dict('records'),
                dash.no_update,
                filtered_df.to_dict('records'),
                reset_clicked,
                {"display": "block"},
                polygon_active,
                dash.no_update
            )



app.layout = html.Div(
    [
        dcc.Tabs(
            [
                dcc.Tab(label='Geo-Location', children=tab_layout(), style=tab_style, selected_style=selected_tab_style),
            ]
        )
    ]
)

if __name__ == '__main__':
    app.run_server(host='100.118.47.56', port=8052, debug=True)
